# Next.js TypeScript Configuration Guide

## Overview

TypeScript is a typed superset of JavaScript that helps catch errors early in the development process. Next.js provides built-in TypeScript support, making it easy to add static typing to your application.

## Enabling TypeScript

### During Project Creation

When creating a new Next.js project, you'll be prompted to add TypeScript support:

```bash
npx create-next-app@latest my-app
# You'll be asked: "Would you like to use TypeScript? (Yes/No)"
```

### Adding TypeScript to Existing Projects

If you have an existing JavaScript project, you can add TypeScript:

1. Install TypeScript and related dependencies:
```bash
npm install --save-dev typescript @types/react @types/node
```

2. Create a `tsconfig.json` file (or rename `jsconfig.json` to `tsconfig.json`)

3. Start the TypeScript compiler:
```bash
npx tsc --init
```

4. Change file extensions from `.js` to `.tsx` or `.ts`

5. Run `npm run dev` - Next.js will automatically configure TypeScript for you

## tsconfig.json Configuration

### Default Next.js Configuration

When you enable TypeScript in a Next.js project, you'll get a default `tsconfig.json`:

```json
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "es6"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```

### Key Compiler Options Explained

#### Target
```json
"target": "es5"
```
Sets the JavaScript version to compile to. ES5 ensures broad browser compatibility.

#### Lib
```json
"lib": ["dom", "dom.iterable", "es6"]
```
Includes type definitions for DOM APIs, iterable objects, and ES6 features.

#### allowJs
```json
"allowJs": true
```
Allows JavaScript files to be imported in TypeScript files (useful during migration).

#### skipLibCheck
```json
"skipLibCheck": true
```
Skips type checking of declaration files, which speeds up compilation.

#### strict
```json
"strict": true
```
Enables all strict type checking options for maximum type safety.

#### noEmit
```json
"noEmit": true
```
Prevents TypeScript from emitting compiled JavaScript files (Next.js handles compilation).

#### jsx
```json
"jsx": "preserve"
```
Preserves JSX syntax for Next.js to handle during compilation.

#### plugins
```json
"plugins": [
  {
    "name": "next"
  }
]
```
Enables Next.js-aware TypeScript type checking in editors.

## TypeScript with Next.js Specific Features

### Page Components

#### App Router Pages
```typescript
// app/page.tsx
export default function HomePage() {
  return (
    <main>
      <h1>Welcome to Next.js!</h1>
    </main>
  );
}

// With props
interface HomePageProps {
  title: string;
  description: string;
}

export default function HomePage({ title, description }: HomePageProps) {
  return (
    <main>
      <h1>{title}</h1>
      <p>{description}</p>
    </main>
  );
}
```

#### Dynamic Route Parameters
```typescript
// app/blog/[slug]/page.tsx
interface BlogPostPageProps {
  params: Promise<{
    slug: string;
  }>;
  searchParams: Promise<{
    [key: string]: string | string[];
  }>;
}

export default async function BlogPostPage({
  params,
  searchParams
}: BlogPostPageProps) {
  const { slug } = await params;
  const { category } = await searchParams;

  return (
    <article>
      <h1>Blog Post: {slug}</h1>
      {category && <p>Category: {category}</p>}
    </article>
  );
}
```

### Layout Components
```typescript
// app/layout.tsx
import { ReactNode } from 'react';

interface RootLayoutProps {
  children: ReactNode;
}

export const metadata = {
  title: 'My App',
  description: 'Generated by create next app',
};

export default function RootLayout({ children }: RootLayoutProps) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}
```

### API Routes
```typescript
// app/api/users/route.ts
import { NextRequest } from 'next/server';

interface User {
  id: number;
  name: string;
  email: string;
}

export async function GET(request: NextRequest) {
  const users: User[] = [
    { id: 1, name: 'John Doe', email: 'john@example.com' },
    { id: 2, name: 'Jane Smith', email: 'jane@example.com' },
  ];

  return Response.json(users);
}

export async function POST(request: NextRequest) {
  const body: Partial<User> = await request.json();

  if (!body.name || !body.email) {
    return Response.json(
      { error: 'Name and email are required' },
      { status: 400 }
    );
  }

  // Process the new user
  const newUser: User = {
    id: Date.now(),
    name: body.name,
    email: body.email,
  };

  return Response.json(newUser, { status: 201 });
}
```

## Client Components

When using TypeScript with client components, you need to add the `'use client'` directive:

```typescript
'use client';

import { useState } from 'react';

interface CounterProps {
  initialValue?: number;
  maxValue?: number;
}

export default function Counter({
  initialValue = 0,
  maxValue = 10
}: CounterProps) {
  const [count, setCount] = useState<number>(initialValue);

  const increment = () => {
    if (count < maxValue) {
      setCount(prev => prev + 1);
    }
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment} disabled={count >= maxValue}>
        Increment
      </button>
    </div>
  );
}
```

## TypeScript with Hooks

### Custom Hooks
```typescript
// hooks/useUser.ts
import { useState, useEffect } from 'react';

interface User {
  id: number;
  name: string;
  email: string;
}

export function useUser(userId: number) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchUser = async () => {
      try {
        setLoading(true);
        const response = await fetch(`/api/users/${userId}`);
        if (!response.ok) throw new Error('Failed to fetch user');

        const userData: User = await response.json();
        setUser(userData);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    };

    if (userId) {
      fetchUser();
    }
  }, [userId]);

  return { user, loading, error };
}
```

### Using React Hooks with Types
```typescript
import { useState, useEffect, useRef } from 'react';

export default function UserProfile() {
  const [name, setName] = useState<string>('');
  const [email, setEmail] = useState<string>('');
  const [isValid, setIsValid] = useState<boolean>(false);
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    setIsValid(email.includes('@'));
  }, [email]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    console.log({ name, email });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        ref={inputRef}
        type="text"
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Name"
      />
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="Email"
        className={!isValid ? 'error' : ''}
      />
      <button type="submit" disabled={!isValid}>
        Submit
      </button>
    </form>
  );
}
```

## TypeScript with Next.js Components

### Image Component
```typescript
import Image from 'next/image';

interface AvatarProps {
  src: string;
  alt: string;
  size?: number;
}

export default function Avatar({
  src,
  alt,
  size = 64
}: AvatarProps) {
  return (
    <Image
      src={src}
      alt={alt}
      width={size}
      height={size}
      className="rounded-full"
    />
  );
}
```

### Link Component
```typescript
import Link from 'next/link';

interface NavLinkProps {
  href: string;
  children: React.ReactNode;
  isActive?: boolean;
}

export default function NavLink({
  href,
  children,
  isActive = false
}: NavLinkProps) {
  return (
    <Link
      href={href}
      className={`nav-link ${isActive ? 'active' : ''}`}
    >
      {children}
    </Link>
  );
}
```

## Type Definitions for Next.js Features

### Metadata
```typescript
import type { Metadata } from 'next';

export const metadata: Metadata = {
  title: 'My Page',
  description: 'This is my page',
  openGraph: {
    title: 'My Page',
    description: 'This is my page',
    type: 'website',
  },
};

// Dynamic metadata
export async function generateMetadata(): Promise<Metadata> {
  const post = await getPost(); // Assume this fetches data

  return {
    title: post.title,
    description: post.description,
  };
}
```

### Dynamic Params
```typescript
// For dynamic routes that need to be pre-generated
export async function generateStaticParams() {
  const posts = await getPosts(); // Assume this fetches data

  return posts.map((post: { id: string }) => ({
    id: post.id,
  }));
}
```

## Advanced TypeScript Patterns

### Union Types for Props
```typescript
interface ButtonProps {
  variant: 'primary' | 'secondary' | 'outline';
  size: 'small' | 'medium' | 'large';
  onClick?: () => void;
  children: React.ReactNode;
  disabled?: boolean;
}

export default function Button({
  variant,
  size,
  onClick,
  children,
  disabled = false
}: ButtonProps) {
  return (
    <button
      className={`btn btn-${variant} btn-${size}`}
      onClick={onClick}
      disabled={disabled}
    >
      {children}
    </button>
  );
}
```

### Generic Components
```typescript
interface ListProps<T> {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
  keyExtractor: (item: T) => string | number;
}

export default function List<T>({
  items,
  renderItem,
  keyExtractor
}: ListProps<T>) {
  return (
    <ul>
      {items.map(item => (
        <li key={keyExtractor(item)}>
          {renderItem(item)}
        </li>
      ))}
    </ul>
  );
}

// Usage
const users = [
  { id: 1, name: 'John' },
  { id: 2, name: 'Jane' },
];

<List
  items={users}
  renderItem={(user) => <span>{user.name}</span>}
  keyExtractor={(user) => user.id}
/>;
```

## Path Aliases

Next.js supports path aliases through the `tsconfig.json` configuration:

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"],
      "@/components/*": ["components/*"],
      "@/lib/*": ["lib/*"],
      "@/hooks/*": ["hooks/*"],
      "@/types/*": ["types/*"]
    }
  }
}
```

### Using Path Aliases
```typescript
// Instead of: import Button from '../../../components/Button';
// Use:
import Button from '@/components/Button';
import { useUser } from '@/hooks/useUser';
import { APIResponse } from '@/types/api';
import { formatDate } from '@/lib/utils';
```

## Type Checking and Development

### Running Type Checks
```bash
# Run type checking in watch mode
npx tsc --watch

# Run type checking once
npx tsc --noEmit

# Or use the script defined in package.json
npm run type-check
```

### Adding Type Check to Build Process
```json
// package.json
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "type-check": "tsc --noEmit"
  }
}
```

## Common TypeScript Patterns in Next.js

### Error Boundaries
```typescript
'use client';

import { Component, ReactNode } from 'react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
}

export default class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(): State {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: any) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }

    return this.props.children;
  }
}
```

### Loading Components
```typescript
interface LoadingProps {
  size?: 'sm' | 'md' | 'lg';
}

export default function Loading({ size = 'md' }: LoadingProps) {
  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-8 h-8',
    lg: 'w-12 h-12',
  };

  return (
    <div className="flex justify-center items-center">
      <div
        className={`${sizeClasses[size]} animate-spin rounded-full border-b-2 border-gray-900`}
      />
    </div>
  );
}
```

## Troubleshooting TypeScript Issues

### Module Resolution Issues
If you encounter module resolution errors:

1. Ensure TypeScript version is compatible with Next.js
2. Verify `tsconfig.json` has the correct configuration
3. Run `npm run dev` to let Next.js generate the correct type files

### Type Errors with Next.js Components
If you get type errors with Next.js-specific components:

```typescript
// Ensure you have the right types installed
npm install --save-dev @types/react @types/node
```

### Missing Type Definitions
For third-party libraries without type definitions:

```bash
# Install type definitions
npm install --save-dev @types/library-name

# Or create a declaration file
// types/library-name.d.ts
declare module 'library-name' {
  export function someFunction(): void;
}
```

## Best Practices

1. **Enable strict mode** for maximum type safety
2. **Use path aliases** to simplify imports
3. **Define interfaces** for complex props and data structures
4. **Use generic types** for reusable components
5. **Validate types during build** by adding type checking to your CI/CD pipeline
6. **Use React's built-in types** like React.ReactNode, React.FC, etc.
7. **Keep type definitions organized** in a separate types directory if needed

Following these practices will help you build robust, maintainable Next.js applications with TypeScript.